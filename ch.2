library(dplyr)
library(tidyr)
library(FW)
library(readxl)
library(asreml)
library(patchwork)
library(rrBLUP)
library(ggplot2)
library(ggpubr)
library(gghighlight)
library(purrr)
library(ggcorrplot)
library(tibble)
library(FW)



df=mat #OR hea

##########
#load('data.ch.2')
df$GENOTYPE=as.factor(df$GENOTYPE)
df$ENV=as.factor(df$ENV)
df$EXPERIMENT=as.factor(df$EXPERIMENT)


######
#VARIANCE EXPLAINED BY EACH COMPONENT?
#####

trait <- "MAT"
df <- df %>%
  mutate(
    GENOTYPE  = as.factor(GENOTYPE),
    ENV       = as.factor(ENV),
    EXPERIMENT= as.factor(EXPERIMENT),
    ROW       = as.factor(ROW),
    COLUMN    = as.factor(COLUMN)
  )

mod <- asreml(
  fixed = as.formula(paste0(trait, " ~ GENOTYPE")),
  random = ~EXPERIMENT + ROW + COLUMN + GENOTYPE + ENV + GENOTYPE:ENV,
  residual = ~units,
  na.action = na.method(x = "include", y = "include"),
  workspace = "2gb",
  data = df,
  maxit = 13,
  ai.sing = TRUE
)

  
# Update the model 5 times
for (i in 1:5) {
    mod <- update(mod)
}
  
vc <- summary(mod)$varcomp
comp_values <- as.numeric(vc[,"component"])
comp_names <- rownames(vc)
pct_var <- round(100 * comp_values / sum(comp_values))
  
var_table <- data.frame(
Component = comp_names,
Variance = comp_values,
Percent_of_Total = pct_var)
  


##########
#NORMALIZATION STEP ACCROSS EXPERIMENTS AND BLUES EXTRACTION 
########
trait <- "MAT"   # Or "MAT" or your desired trait name

# ---- 1. NB ----
df_NB <- subset(df, ENV == "NB")

mod_NB <- asreml(
  fixed    = as.formula(paste0(trait, " ~ GENOTYPE")),
  random   = ~ EXPERIMENT+ROW+COLUMN,
  residual = ~ units,
  data     = df_NB,
  na.action = na.method(x = "include", y = "include"),
  workspace = "1gb"
)
for (i in 1:5) mod_NB <- update(mod_NB)

coefs_NB <- summary(mod_NB, coef=TRUE)$coef.fixed
intercept_NB <- coefs_NB["(Intercept)", "solution"]
gidx_NB <- grep("^GENOTYPE_", rownames(coefs_NB), value=TRUE)
geno_names_NB <- sub("^GENOTYPE_", "", gidx_NB)
ref_NB <- setdiff(levels(df_NB$GENOTYPE)[1], geno_names_NB) # Only not-reported

blues_NB <- data.frame(
  GENOTYPE = geno_names_NB,
  ENV = "NB",
  stringsAsFactors = FALSE
)
blues_NB[[trait]] <- intercept_NB + coefs_NB[gidx_NB, "solution"]

# Only add the reference genotype if not present
if (length(ref_NB) == 1) {
  temp_df <- data.frame(
    GENOTYPE = ref_NB,
    ENV = "NB",
    stringsAsFactors = FALSE
  )
  temp_df[[trait]] <- intercept_NB
  blues_NB <- rbind(blues_NB, temp_df[, c("GENOTYPE", trait, "ENV")])
}
blues_NB <- blues_NB[!duplicated(blues_NB[,c("GENOTYPE", "ENV")]), ]
blues_NB <- blues_NB[order(blues_NB$GENOTYPE), ]
rownames(blues_NB) <- NULL

# ---- 2. SB ----
df_SB <- subset(df, ENV == "SB")

mod_SB <- asreml(
  fixed    = as.formula(paste0(trait, " ~ GENOTYPE")),
  random   = ~ EXPERIMENT+ROW+COLUMN,
  residual = ~ units,
  data     = df_SB,
  na.action = na.method(x = "include", y = "include"),
  workspace = "1gb"
)
for (i in 1:5) mod_SB <- update(mod_SB)

coefs_SB <- summary(mod_SB, coef=TRUE)$coef.fixed
intercept_SB <- coefs_SB["(Intercept)", "solution"]
gidx_SB <- grep("^GENOTYPE_", rownames(coefs_SB), value=TRUE)
geno_names_SB <- sub("^GENOTYPE_", "", gidx_SB)
ref_SB <- setdiff(levels(df_SB$GENOTYPE)[1], geno_names_SB)

blues_SB <- data.frame(
  GENOTYPE = geno_names_SB,
  ENV = "SB",
  stringsAsFactors = FALSE
)
blues_SB[[trait]] <- intercept_SB + coefs_SB[gidx_SB, "solution"]

# Only add the reference genotype if not present
if (length(ref_SB) == 1) {
  temp_df <- data.frame(
    GENOTYPE = ref_SB,
    ENV = "SB",
    stringsAsFactors = FALSE
  )
  temp_df[[trait]] <- intercept_SB
  blues_SB <- rbind(blues_SB, temp_df[, c("GENOTYPE", trait, "ENV")])
}
blues_SB <- blues_SB[!duplicated(blues_SB[,c("GENOTYPE", "ENV")]), ]
blues_SB <- blues_SB[order(blues_SB$GENOTYPE), ]
rownames(blues_SB) <- NULL

# ---- Combine NB and SB ----
blues_all <- rbind(blues_NB, blues_SB)

# Inspect:
head(blues_all)
bluesmat=blues_all
# Add the new columns
pheno$HEA.sensitivity <- pheno$HEA.NB - pheno$HEA.SB
pheno$MAT.sensitivity <- pheno$MAT.NB - pheno$MAT.SB
###########
#FeW
##########
FWR.OLS = FW(y = bluesmat$MAT,VAR = bluesmat$GENOTYPE,ENV = bluesmat$ENV,A=NULL,
             method=c("OLS","Gibbs")[1],seed=12345,nIter = 50000,burnIn = 5000) 
pheno.OLS <- data.frame(
  GENOTYPE = levels(FWR.OLS$VAR),
  g.OLS = FWR.OLS$g,
  b.OLS = FWR.OLS$b,
  check.names = FALSE # Prevent autoMATic renaming
)



new_column_names.OLS <- c(
  "GENOTYPE",         # FWR.Gibbs$VAR
  "g.OLS",     # FWR.Gibbs$g
  "b.OLS"     # FWR.Gibbs$b
)

names(pheno.OLS) <- new_column_names.OLS

pheno1=pheno.OLS

cor(pheno1$g.OLS, pheno1$b.OLS, use = "complete.obs")

# Identify columns starting with "b" and "g"
b_columns <- grep("^b", names(pheno1), value = TRUE)
g_columns <- grep("^g", names(pheno1), value = TRUE)

# MATch "b" columns with corresponding "g" columns by suffix
for (b_col in b_columns) {
  # Extract the suffix (everything after the first ".")
  suffix <- sub("^b\\.", "", b_col)
  g_col <- paste0("g.", suffix)
  
  if (g_col %in% g_columns) {
    # Calculate covariance and variance dynamically
    sigma_bg <- cov(pheno1[[b_col]], pheno1[[g_col]], use = "complete.obs")
    sigma2_g <- var(pheno1[[g_col]], na.rm = TRUE)
    
    # Create the new column name for the transformed "b" column
    new_col_name <- paste0("b*", b_col)
    
    # Apply the transforMATion and add to the dataframe
    pheno1[[new_col_name]] <- (pheno1[[b_col]] - ((sigma_bg / sigma2_g))*pheno1[[g_col]])
  } else {
    warning(paste("No MATching g column found for", b_col))
  }
}

cor(pheno1$g.OLS, pheno1$`b*b.OLS`, use = "complete.obs")
# Environmental indices

h_NB <- FWR.OLS[["h"]][1, 1]
h_SB <- FWR.OLS[["h"]][2, 1]

# Calculate MAT values for each environment, both original and corrected (using b*b.OLS)
pheno1 <- pheno1 %>%
  mutate(
    MAT.NB = g.OLS + b.OLS * h_NB + h_NB,
    MAT.SB = g.OLS + b.OLS * h_SB + h_SB,
    MAT.NB.corrected = g.OLS + `b*b.OLS` * h_NB + h_NB,
    MAT.SB.corrected = g.OLS + `b*b.OLS` * h_SB + h_SB,
    rank_SB = rank(MAT.SB)
  )

# Pivot to long format for plotting
plot_df <- pheno1 %>%
  select(GENOTYPE, MAT.NB, MAT.SB, MAT.NB.corrected, MAT.SB.corrected, rank_SB) %>%
  pivot_longer(
    cols = c(MAT.NB, MAT.NB.corrected),
    names_to = "NB_type", values_to = "NB"
  ) %>%
  pivot_longer(
    cols = c(MAT.SB, MAT.SB.corrected),
    names_to = "SB_type", values_to = "SB"
  ) %>%
  filter(
    (NB_type == "MAT.NB" & SB_type == "MAT.SB") |
      (NB_type == "MAT.NB.corrected" & SB_type == "MAT.SB.corrected")
  ) %>%
  mutate(type = ifelse(NB_type == "MAT.NB", "Original", "Corrected"))

# For line plotting: one row per GENOTYPE per type with both environments
line_df <- plot_df %>%
  select(GENOTYPE, type, NB, SB, rank_SB) %>%
  pivot_longer(cols = c(NB, SB), names_to = "env", values_to = "MAT") %>%
  mutate(env = factor(env, levels = c("SB", "NB")))  # SB first for clarity

# Plot
p <- ggplot(line_df, aes(x = env, y = MAT, group = GENOTYPE, color = rank_SB)) +
  geom_line(alpha = 0.8) +
  scale_color_viridis_c(option = "plasma", name = "Rank of MAT.SB") +
  facet_wrap(~type) +
  theme_minimal() +
  labs(x = "Environment", y = "MAT (Days)", title = "MAT by Environment and Rank") +
  theme(strip.text = element_text(face = "bold"))

print(p)
ggsave("C://Users//NRossi//OneDrive - SRUC/THESIS//final//ch.2//final final//MAT.scalecorrectedplot.tiff", plot = p, dpi = 600, width = 8, height = 6, units = "in")

# Correlation between slopes and plasticity
hea_slope_plasticity_cor <- cor(pheno$HEA.slope, pheno$HEA.plasticity, use = "complete.obs")
mat_slope_plasticity_cor <- cor(pheno$MAT.slope, pheno$MAT.plasticity, use = "complete.obs")


# Print results
cat("HEA slope ~ HEA plasticity correlation:", hea_slope_plasticity_cor, "\n")
cat("MAT slope ~ MAT plasticity correlation:", mat_slope_plasticity_cor, "\n")
# Correlation between slopes and plasticity
hea_slope_plasticity_cor <- cor(pheno$HEA.slope, pheno$HEA.plasticity, use = "complete.obs")
mat_slope_plasticity_cor <- cor(pheno$MAT.slope, pheno$MAT.plasticity, use = "complete.obs")

# Correlation between slopes and corrected slopes
hea_slope_corrslope_cor <- cor(pheno$HEA.slope, pheno$HEA.corrected.slope, use = "complete.obs")
mat_slope_corrslope_cor <- cor(pheno$MAT.slope, pheno$MAT.corrected.slope, use = "complete.obs")

# Print results
cat("HEA slope ~ HEA plasticity correlation:", hea_slope_plasticity_cor, "\n")
cat("MAT slope ~ MAT plasticity correlation:", mat_slope_plasticity_cor, "\n")
cat("HEA slope ~ HEA corrected slope correlation:", hea_slope_corrslope_cor, "\n")
cat("MAT slope ~ MAT corrected slope correlation:", mat_slope_corrslope_cor, "\n")



###########
#TRAITS HISTOGRAM
########

# Transform to long format for plotting
pheno_long <- pheno %>%
  pivot_longer(
    cols = -GENOTYPE,
    names_to = "Trait",
    values_to = "Value"
  )

plot_hist <- function(traitname) {
  vals <- pheno_long %>% filter(Trait == traitname) %>% pull(Value)
  mu <- mean(vals, na.rm=TRUE)
  sigma <- sd(vals, na.rm=TRUE)
  ggplot(pheno_long %>% filter(Trait == traitname), aes(x=Value)) +
    geom_histogram(aes(y=..density..), fill = "steelblue", color = "black", bins = 20, alpha = 0.7) +
    stat_function(fun = dnorm, args = list(mean=mu, sd=sigma),
                  color = "black", linetype = "dashed", size = 1) +
    labs(title = traitname, x = NULL, y = "Density") +     # Remove x axis label, keep ticks
    theme_bw() +
    theme(
      plot.title = element_text(hjust = 0.5)
      # No axis.text.x or axis.ticks.x here!
    )
}


# In this order: first row HEA, second MAT
traits_to_plot <- c("HEA.NB", "HEA.SB", "HEA.plasticity", "MAT.NB", "MAT.SB", "MAT.plasticity", "HEA.slope", "HEA.corrected.slope", "MAT.slope", "MAT.corrected.slope")
plots <- lapply(traits_to_plot, plot_hist)

final_plot <- (plots[[1]] + plots[[2]] + plots[[3]] + plots[[7]] + plots[[8]]) /
  (plots[[4]] + plots[[5]] + plots[[6]] + plots[[9]] + plots[[10]]) +
  plot_annotation(tag_levels = 'a')

final_plot



ggsave("C://Users//NRossi//OneDrive - SRUC//Thesis - Nicola Rossi//ch.2//Figure2.6.tiff", plot = final_plot, dpi = 600, width = 8, height = 6, units = "in")



#######
#CORMATRIX&SUMMARY STATISTICS&bocplots
######

num_vars <- pheno %>% select(where(is.numeric))
cor_matrix <- cor(num_vars, use = "pairwise.complete.obs")

cor_df <- as.data.frame(as.table(cor_matrix))
names(cor_df) <- c("Var1", "Var2", "Correlation")

# Set factor levels to preserve variable order
cor_df$Var1 <- factor(cor_df$Var1, levels = colnames(cor_matrix))
cor_df$Var2 <- factor(cor_df$Var2, levels = colnames(cor_matrix))

# Keep only lower triangle
cor_df_lower <- cor_df %>% 
  filter(as.numeric(Var1) >= as.numeric(Var2))

p=ggplot(cor_df_lower, aes(Var1, Var2, fill = Correlation)) +
  geom_tile(color = "white") +
  scale_fill_gradient2(low = "#B2182B", mid = "white", high = "#2166AC", midpoint = 0, limit = c(-1,1)) +
  geom_text(aes(label = sprintf("%.2f", Correlation)), color = "black", size = 4) +
  theme_minimal() +
  labs(title = "Correlation Matrix",
       x = "", y = "") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

ggsave("C://Users//NRossi//OneDrive - SRUC//THESIS//final//ch.2//final final//figure 4.tiff", plot = p, dpi = 600, width = 8, height = 6, units = "in")
summary_stats <- num_vars %>%
  summarise(across(
    everything(),
    list(
      Count = ~sum(!is.na(.)),
      Mean = ~mean(., na.rm = TRUE),
      SD = ~sd(., na.rm = TRUE),
      Min = ~min(., na.rm = TRUE),
      Q1 = ~quantile(., 0.25, na.rm = TRUE),
      Median = ~median(., na.rm = TRUE),
      Q3 = ~quantile(., 0.75, na.rm = TRUE),
      Max = ~max(., na.rm = TRUE)
    ),
    .names = "{.col}_{.fn}"
  )) %>%
  pivot_longer(
    everything(),
    names_to = c("Variable", ".value"),
    names_pattern = "(.*)_(.*)"
  )
print(summary_stats)

#FOR LANDRACES VS CULTIVARS
summary_stats_by_group <- lrcv %>%
  group_by(Genotype_Group,ENV) %>%
  summarise(
    Count  = sum(!is.na(HEA)),
    Mean   = mean(HEA, na.rm = TRUE),
    SD     = sd(HEA, na.rm = TRUE),
    Min    = min(HEA, na.rm = TRUE),
    Q1     = quantile(HEA, 0.25, na.rm = TRUE),
    Median = median(HEA, na.rm = TRUE),
    Q3     = quantile(HEA, 0.75, na.rm = TRUE),
    Max    = max(HEA, na.rm = TRUE),
    .groups = "drop"
  )

print(summary_stats_by_group)



# Find a common y-range (here c(30, 120) covers your sample, adjust as needed)
ylim_common <- c(
  min(c(blueshea$HEA, bluesmat$MAT), na.rm = TRUE),
  max(c(blueshea$HEA, bluesmat$MAT), na.rm = TRUE)
)

# HEA boxplot
p_hea <- ggplot(blueshea, aes(x = ENV, y = HEA, fill = ENV)) +
  geom_boxplot(outlier.shape = NA, alpha = 0.6) +
  geom_jitter(aes(color = ENV), width = 0.2, size = 1.5, alpha = 0.7) +
  scale_fill_manual(values = c("NB" = "blue", "SB" = "red"), name = "Condition", labels = c("NB" = "NB", "SB" = "SB")) +
  scale_color_manual(values = c("NB" = "blue", "SB" = "red"), name = "Condition", labels = c("NB" = "NB", "SB" = "SB")) +
  labs(x = "Condition", y = "Heading (Days)") +
  coord_cartesian(ylim = ylim_common) +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = -0.11, vjust = 1.8, size = 16, face = "bold"),
    legend.title = element_text(face = "plain", size = 10),
    legend.text = element_text(size = 9)
  ) +
  ggtitle("a")

# MAT boxplot
p_mat <- ggplot(bluesmat, aes(x = ENV, y = MAT, fill = ENV)) +
  geom_boxplot(outlier.shape = NA, alpha = 0.6) +
  geom_jitter(aes(color = ENV), width = 0.2, size = 1.5, alpha = 0.7) +
  scale_fill_manual(values = c("NB" = "blue", "SB" = "red"), name = "Condition", labels = c("NB" = "NB", "SB" = "SB")) +
  scale_color_manual(values = c("NB" = "blue", "SB" = "red"), name = "Condition", labels = c("NB" = "NB", "SB" = "SB")) +
  labs(x = "Condition", y = "Maturity (Days)") +
  coord_cartesian(ylim = ylim_common) +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = -0.11, vjust = 1.8, size = 16, face = "bold"),
    legend.title = element_text(face = "plain", size = 10),
    legend.text = element_text(size = 9)
  ) +
  ggtitle("b")

# Combine with patchwork
p=p_hea + p_mat

ggsave("C://Users//NRossi//OneDrive - SRUC//THESIS//final//ch.2//final final//figure 5.tiff", plot = p, dpi = 600, width = 8, height = 6, units = "in")



#########
#GWAS
#######
pheno=pheno1

geno.gwas= markers[rownames(markers)%in%pheno$GENOTYPE,]
pheno=pheno[pheno$GENOTYPE%in%rownames(geno.gwas),]
geno.gwas <- geno.gwas[,colnames(geno.gwas)%in%map$Locus]
imputation=A.mat(geno.gwas,impute.method="EM",return.imputed=T,min.MAF=0.05)
k.mat=imputation$A
geno.gwas=imputation$imputed
map <- map[map$Locus%in%colnames(geno.gwas),]
pheno=pheno[pheno$GENOTYPE%in%rownames(geno.gwas),]
geno.gwas=geno.gwas[rownames(geno.gwas)%in%pheno$GENOTYPE,]
geno.gwas1=t(geno.gwas)
geno.gwas1.1=data.frame(Locus=rownames(geno.gwas1),geno.gwas1)
geno.gwas2=merge(map,geno.gwas1.1,by="Locus", all.x=TRUE)
pheno=as.data.frame(pheno)
gwasmodel= GWAS(pheno=pheno,geno=geno.gwas2,K=k.mat,min.MAF = 0.05,n.PC=6,plot=FALSE)

gwasmodel <- gwasmodel %>%
  select(Locus, Chromosome, Position, 
         HEA.NB, HEA.SB, HEA.plasticity,HEA.slope,HEA.corrected.slope, 
         MAT.NB, MAT.SB, MAT.plasticity,MAT.slope,MAT.corrected.slope )


library(CMplot)
setwd("C://Users//NRossi//OneDrive - SRUC//THESIS//final//ch.2//final final")
CMplot(gwasmodel[c(1:3)],plot.type="m",LOG10=F,threshold=4,threshold.col="black",threshold.lty=1,
       col=c("grey30","grey60"),ylim=c(0,9),
       signal.cex=1.2,signal.col="red",highlight.col="grey",highlight.cex=0.7,
       file="jpg",dpi=600,file.output=T,verbose=T,multracks=T)


CMplot(gwasmodel[c(1:3,9:13)],plot.type="m",LOG10=F,threshold=4,threshold.col="black",threshold.lty=1,
       col=c("grey30","grey60"),ylim=c(0,9),
       signal.cex=1.2,signal.col="red",highlight.col="grey",highlight.cex=0.7,
       file="jpg",dpi=600,file.output=T,verbose=T,multracks=T)



################***CHECKING POPULATION STRUCTURE EFFECTS***###############
## Principal components analysis

pca1=prcomp(markers,scale=TRUE)
pca1_loading=pca1$x
explained_variance <- 100 * (pca1$sdev^2 / sum(pca1$sdev^2))

# Create a scree plot
tiff("C://Users//NRossi//OneDrive - SRUC//THESIS//final//ch.2//final final//screeplot.tiff", width=6, height=5, units="in", res=600)


plot(
  explained_variance[1:15],
  type="o",
  main="Screeplot",
  xlab="Principal Component",
  ylab="% Variance Explained"
)
dev.off()


pca1_loading=data.frame(GENOTYPE=rownames(pca1_loading),PC1=pca1_loading[,"PC1"],PC2=pca1_loading[,"PC2"])

pca1_loading$Group <- ifelse(
  pca1_loading$GENOTYPE %in% pheno$GENOTYPE,
  'used genotypes',
  'not used genotypes'
)

p=ggplot(pca1_loading, aes(x = PC1, y = PC2, color = Group,shape=Group)) +
  geom_point(alpha=0.5,size=2) +
  labs(x = "PC1 (2.37%)", y = "PC2 (2.26%)")+
  scale_shape_manual(values=c(16,17))+
  theme_classic()+
  scale_color_brewer(palette="Set1")+
  theme(axis.text=element_text(size=12),
        axis.title=element_text(size=14,face="bold"))

ggsave("C://Users//NRossi//OneDrive - SRUC//THESIS//final//ch.2//final final//PCA.tiff", plot = p, dpi = 600, width = 8, height = 6, units = "in")





########
#FIGURE SENSITIVITY
#######

pheno1=pheno #dataframe from 2 steps few model

pheno1 <- pheno %>%
  left_join(
    markers[, c("JHI_Hv50k_2016_56724", "JHI_Hv50k_2016_72948")] %>%
      as.data.frame() %>%
      rownames_to_column(var = "GENOTYPE"),
    by = "GENOTYPE"
  )

# Filter out rows with 0s in the specified columns (heterozygous)
pheno1 <- pheno1 %>% 
  filter(JHI_Hv50k_2016_56724 != 0, JHI_Hv50k_2016_72948 != 0)

# Add the $geno column based on combinations of the two marker columns
pheno1 <- pheno1 %>%
  mutate(
    geno = case_when(
      JHI_Hv50k_2016_56724 == -1 & JHI_Hv50k_2016_72948 == -1 ~ "ELF3hv/PPDH1hv",
      JHI_Hv50k_2016_56724== 1 & JHI_Hv50k_2016_72948== -1 ~ "ELF3hsp/PPDH1hv",
      JHI_Hv50k_2016_56724 == -1 & JHI_Hv50k_2016_72948== 1 ~ "ELF3hv/PPDH1hsp",
      JHI_Hv50k_2016_56724== 1 & JHI_Hv50k_2016_72948 == 1 ~ "ELF3hsp/PPDH1hsp",
      TRUE ~ NA_character_ # Handle unexpected cases with NA
    ),
    genow.d = case_when(
      JHI_Hv50k_2016_56724 == -1 & JHI_Hv50k_2016_72948== -1 ~ "domesticated",
      JHI_Hv50k_2016_56724 == 1 & JHI_Hv50k_2016_72948 == 1 ~ "wild",
      JHI_Hv50k_2016_56724 == 1 & JHI_Hv50k_2016_72948 == -1~"wild",
      JHI_Hv50k_2016_56724 == -1 & JHI_Hv50k_2016_72948 == 1~"wild",
      TRUE ~ NA_character_ # Handle unexpected cases with NA
    )
  )


# 1. Prepare long data
pheno1_long_hea <- pheno1 %>%
  select(GENOTYPE, geno, HEA.sensitivity, HEA.NB, HEA.SB) %>%
  pivot_longer(
    cols = c(HEA.NB, HEA.SB),
    names_to = "ENV",
    names_prefix = "HEA.",
    values_to = "HEA"
  )

pheno1_long_mat <- pheno1 %>%
  select(GENOTYPE, geno, MAT.sensitivity, MAT.NB, MAT.SB) %>%
  pivot_longer(
    cols = c(MAT.NB, MAT.SB),
    names_to = "ENV",
    names_prefix = "MAT.",
    values_to = "MAT"
  )

# 2. Calculate cutoffs
n_gen <- pheno1 %>% distinct(GENOTYPE) %>% nrow()
n_half <- floor(n_gen / 2)

cutoff_hea <- pheno1 %>% arrange(HEA.sensitivity) %>% slice(n_half) %>% pull(HEA.sensitivity)
cutoff_mat <- pheno1 %>% arrange(MAT.sensitivity) %>% slice(n_half) %>% pull(MAT.sensitivity)

# 3. Consistent color palette for "geno" group
# If there are a lot of geno groups, use a colorblind-friendly palette

geno_groups <- unique(pheno1$geno)
geno_groups <- geno_groups[!is.na(geno_groups)]

my_palette <- setNames(
  c("green", "yellow", "blue", "violet"),
  geno_groups[order(geno_groups)]
)


# ... [Previous code for pheno1_long_hea, pheno1_long_mat, cutoff_hea, cutoff_mat, my_palette] ...

p_hea_low <- ggplot(pheno1_long_hea, aes(x = ENV, y = HEA, group = GENOTYPE, color = geno)) +
  geom_point(size = .5, alpha = 0.3) +
  geom_line(linewidth = .8, alpha = 0.3) +
  gghighlight(HEA.sensitivity <= cutoff_hea, use_direct_label = FALSE) +
  scale_color_manual(values = my_palette) +
  labs(title = "Low sensitivity: HEA", x = NULL, y = "Heading (days)", color = "Genotype group") +
  theme_minimal(base_size = 8) +
  theme(
    legend.position = "none",
    axis.title.y = element_text(size = 8),
    axis.text.y = element_text(size = 8),
    axis.text.x = element_text(size = 8),
    plot.title = element_text(size = 10, hjust = 0.5),
    legend.text = element_text(size=8),
    legend.title = element_text(size=8)
  )

p_hea_high <- ggplot(pheno1_long_hea, aes(x = ENV, y = HEA, group = GENOTYPE, color = geno)) +
  geom_point(size = .5, alpha = 0.3) +
  geom_line(linewidth = .8, alpha = 0.3) +
  gghighlight(HEA.sensitivity > cutoff_hea, use_direct_label = FALSE) +
  scale_color_manual(values = my_palette) +
  labs(title = "High sensitivity: HEA", x = NULL, y = NULL, color = "Genotype group") +
  theme_minimal(base_size = 8) +
  theme(
    legend.position = "top",
    axis.title.y = element_blank(),
    axis.text.y = element_text(size = 8),
    axis.text.x = element_text(size = 8),
    plot.title = element_text(size = 10, hjust = 0.5),
    legend.text = element_text(size=8),
    legend.title = element_text(size=8)
  )

p_mat_low <- ggplot(pheno1_long_mat, aes(x = ENV, y = MAT, group = GENOTYPE, color = geno)) +
  geom_point(size = .5, alpha = 0.3) +
  geom_line(linewidth = .8, alpha = 0.3) +
  gghighlight(MAT.sensitivity <= cutoff_mat, use_direct_label = FALSE) +
  scale_color_manual(values = my_palette) +
  labs(title = "Low sensitivity: MAT", x = "Experimental Condition", y = "Maturity (days)", color = "Genotype group") +
  theme_minimal(base_size = 8) +
  theme(
    legend.position = "none",
    axis.title.y = element_text(size = 8),
    axis.title.x = element_text(size = 8),
    axis.text.y = element_text(size = 8),
    axis.text.x = element_text(size = 8),
    plot.title = element_text(size = 10, hjust = 0.5),
    legend.text = element_text(size=8),
    legend.title = element_text(size=8)
  )

p_mat_high <- ggplot(pheno1_long_mat, aes(x = ENV, y = MAT, group = GENOTYPE, color = geno)) +
  geom_point(size = .5, alpha = 0.3) +
  geom_line(linewidth = .8, alpha = 0.3) +
  gghighlight(MAT.sensitivity > cutoff_mat, use_direct_label = FALSE) +
  scale_color_manual(values = my_palette) +
  labs(title = "High sensitivity: MAT", x = "Experimental Condition", y = NULL, color = "Genotype group") +
  theme_minimal(base_size = 8) +
  theme(
    legend.position = "top",
    axis.title.y = element_blank(),
    axis.title.x = element_text(size = 8),
    axis.text.y = element_text(size = 8),
    axis.text.x = element_text(size = 8),
    plot.title = element_text(size = 10, hjust = 0.5),
    legend.text = element_text(size=8),
    legend.title = element_text(size=8)
  )

final_4plot <- (p_hea_low + p_hea_high) / (p_mat_low + p_mat_high) +
  plot_annotation(tag_levels = 'a')

# Print large in the plotting device:
print(final_4plot)


ggsave("C://Users//NRossi//OneDrive - SRUC//THESIS//final//ch.2//final final//figure6.tiff", plot = final_4plot, dpi = 600, width = 8, height = 6, units = "in")


########################## SCALE-CORRECTED SLOPE WITH BLUPS

library(dplyr)
library(tidyr)
library(FW)
library(readxl)
library(asreml)
library(patchwork)
library(rrBLUP)
library(ggplot2)
library(ggpubr)
library(gghighlight)
library(purrr)
library(ggcorrplot)
library(tibble)
library(FW)



df=hea

##########
#load('data.ch.2')
df$GENOTYPE=as.factor(df$GENOTYPE)
df$ENV=as.factor(df$ENV)
df$EXPERIMENT=as.factor(df$EXPERIMENT)


######
#VARIANCE EXPLAINED BY EACH COMPONENT?
#####

trait <- "HEA"
df <- df %>%
  mutate(
    GENOTYPE  = as.factor(GENOTYPE),
    ENV       = as.factor(ENV),
    EXPERIMENT= as.factor(EXPERIMENT),
    ROW       = as.factor(ROW),
    COLUMN    = as.factor(COLUMN)
  )

# Split data per ENV
env_list <- split(df, df$ENV)

# Fit model per environment and extract genotype BLUPs
geno_blups_list <- lapply(names(env_list), function(env) {
  df_env <- env_list[[env]]
  
  mod <- asreml(
    fixed = HEA ~ 1,
    random = ~ EXPERIMENT + GENOTYPE,
    residual = ~ units,
    data = df_env,
    na.action = na.method(x = "include", y = "include"),
    workspace = "2gb",
    maxit = 13,
    ai.sing = TRUE
  )
  # Update the model 5 times
  for (i in 1:5) {
    mod <- update(mod)
  }
  
  # Extract BLUPs for GENOTYPE
  geno_blups <- coef(mod)$random[grep("^GENOTYPE", rownames(coef(mod)$random)), , drop = FALSE]
  
  tibble(
    ENV = env,
    GENOTYPE = gsub("GENOTYPE_", "", rownames(geno_blups)),
    BLUP = geno_blups[, 1]
  )
})

# Combine into single dataframe
geno_blups_df <- bind_rows(geno_blups_list)

head(geno_blups_df)

ggplot(geno_blups_df, aes(x = ENV, y = BLUP, group = GENOTYPE, color = GENOTYPE)) +
  geom_line(alpha = 0.6) +
  geom_point(size = 2) +
  theme_minimal(base_size = 14) +
  labs(
    x = "Environment",
    y = "Genotypic BLUP",
    title = "Genotype performance across environments"
  ) +
  theme(
    legend.position = "none" # hide if too many genotypes
  )
###########

FWR.BLUP <- FW(
  y   = geno_blups_df$BLUP,
  VAR = geno_blups_df$GENOTYPE,
  ENV = geno_blups_df$ENV,
  A   = NULL,
  method = "OLS",
  seed = 12345,
  nIter = 50000,
  burnIn = 5000
)

# Put into dataframe
pheno.BLUP <- data.frame(
  GENOTYPE = levels(FWR.BLUP$VAR),
  g.BLUP   = FWR.BLUP$g,
  b.BLUP   = FWR.BLUP$b
)

# covariance/variance adjustment
sigma_bg <- cov(pheno.BLUP$b.BLUP, pheno.BLUP$g.BLUP, use = "complete.obs")
sigma2_g <- var(pheno.BLUP$g.BLUP, na.rm = TRUE)

pheno.BLUP$b_corr <- pheno.BLUP$b.BLUP - (sigma_bg / sigma2_g) * pheno.BLUP$g.BLUP

h_vals <- FWR.BLUP$h  # should be a matrix with env loadings
h_envs <- rownames(h_vals)  # should match ENV names (e.g., NB, SB)

# Compute environment-specific values
for (env in h_envs) {
  h <- h_vals[env, 1]
  pheno.BLUP[[paste0("BLUP.", env)]] <- pheno.BLUP$g.BLUP + pheno.BLUP$b.BLUP * h + h
  pheno.BLUP[[paste0("BLUP.", env, ".corrected")]] <- pheno.BLUP$g.BLUP + pheno.BLUP$b_corr * h + h
}

plot_df <- pheno.BLUP %>%
  select(GENOTYPE, starts_with("BLUP.")) %>%
  pivot_longer(
    cols = -GENOTYPE,
    names_to = c("ENV", "correction"),
    names_pattern = "BLUP\\.(.*?)(\\.corrected)?$",
    values_to = "value"
  ) %>%
  mutate(correction = ifelse(is.na(correction), "Original", "Corrected"))


ggplot(plot_df, aes(x = ENV, y = value, group = GENOTYPE, color = correction)) +
  geom_line(alpha = 0.6) +
  geom_point(size = 1.5) +
  facet_wrap(~correction) +
  theme_minimal(base_size = 14) +
  labs(x = "Environment", y = "BLUP (FWR)", title = "Finlayâ€“Wilkinson BLUPs by Environment")


###########

library(dplyr)
library(tidyr)
library(ggplot2)

# Choose which SB to rank by
rank_from <- "Original"  # or "Corrected"
rank_source_col <- if (rank_from == "Corrected") "BLUP.SB.corrected" else "BLUP.SB"

# 1) Compute rank in SB (higher SB => rank 1; flip if lower is better)
pheno.BLUP <- pheno.BLUP %>%
  mutate(rank_SB = dplyr::min_rank(dplyr::desc(.data[[rank_source_col]])))
# If lower SB is better, use: mutate(rank_SB = dplyr::min_rank(.data[[rank_source_col]]))

# 2) Build a tidy long dataset for plotting
long_df <- bind_rows(
  pheno.BLUP %>% transmute(GENOTYPE, type = "Original",  SB = BLUP.SB,            NB = BLUP.NB,            rank_SB),
  pheno.BLUP %>% transmute(GENOTYPE, type = "Corrected", SB = BLUP.SB.corrected,  NB = BLUP.NB.corrected,  rank_SB)
) %>%
  pivot_longer(cols = c(SB, NB), names_to = "ENV", values_to = "BLUP") %>%
  mutate(
    type = factor(type, levels = c("Corrected", "Original")),  # panel order
    ENV  = factor(ENV,  levels = c("SB", "NB"))                # x-axis order
  )

# 3) Plot: two panels, colored by SB rank
p1=ggplot(long_df, aes(x = ENV, y = BLUP, group = GENOTYPE, color = rank_SB)) +
  geom_line(alpha = 0.8) +
  geom_point(size = 1.2) +
  facet_wrap(~ type, ncol = 2) +
  scale_color_viridis_c(
    option = "plasma",
    direction = -1,                    # rank 1 = most intense
    na.value = "grey80",
    name = paste0("Rank in SB (", rank_from, ")")
  ) +
  theme_minimal(base_size = 14) +
  labs(
    x = "Environment",
    y = "BLUP (HEA)",
    title = "Plasticity"
  ) +
  theme(strip.text = element_text(face = "bold"))


str(list(p1 = p1, p2 = p2), max.level = 2, list.len = 6, give.attr = FALSE)

combined <- (p1 / p2) + 
  plot_annotation(tag_levels = "A") & 
  theme(plot.tag = element_text(face = "bold", size = 14))

combined


ggsave("C://Users//NRossi//OneDrive - SRUC//Thesis - Nicola Rossi//ch.2//Figure2.7b.tiff", plot = p2, dpi = 600, width = 8, height = 6, units = "in")


# Add b_corr from pheno.BLUP to pheno as HEA.BLUP.corrected.slope by GENOTYPE
pheno$HEA.BLUP.corrected.slope <- pheno.BLUP$b_corr[
  match(as.character(pheno$GENOTYPE), as.character(pheno.BLUP$GENOTYPE))
]


pheno <- pheno |>
  dplyr::select(
    -HEA.corrected.slope,
    -MAT.corrected.slope,
    everything()
  )

# Rename the BLUP columns into their new positions
colnames(pheno)[colnames(pheno) == "HEA.BLUP.corrected.slope"] <- "HEA.corrected.slope"
colnames(pheno)[colnames(pheno) == "MAT.BLUP.corrected.slope"] <- "MAT.corrected.slope"
# remove the last two duplicate columns
pheno <- pheno[, !duplicated(names(pheno))]

# reorder so corrected slopes follow their slope
pheno <- pheno[, c(
  "GENOTYPE",
  "HEA.NB",
  "HEA.SB",
  "MAT.NB",
  "MAT.SB",
  "HEA.plasticity",
  "MAT.plasticity",
  "HEA.slope",
  "HEA.corrected.slope",   # right after HEA.slope
  "MAT.slope",
  "MAT.corrected.slope"    # right after MAT.slope
)]









